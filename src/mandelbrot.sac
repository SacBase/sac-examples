/*
SEQ 1920 1080
CHECK 1280 720
MT 1920 1080
*/

use Structures: all;
use CommandLine: all;
use StdIO: all;

#ifndef DEPTH
#define DEPTH 2048
#endif

inline
complex[yres,xres] genComplexArray(int xres, int yres, complex cmin, complex cmax)
{
    dR = real(cmax) - real(cmin);
    dI = imag(cmax) - imag(cmin);
    return { [y,x] -> cmin + toc((tod(x) / tod(xres)) * dR,
                                 (tod(y) / tod(yres)) * dI)
           | [y,x] < [yres,xres] };
}

inline
int, complex escapeTimeAndValue(complex c, int depth)
{
    time = 0;
    z = c;

    while (time < depth && normSq(z) <= 4d) {
        z = z * z + c;
        time += 1;
    }

    return (time, z);
}

noinline
int[2:shp], complex[2:shp] escapeTimeAndValue(complex[2:shp] arr, int depth)
{
    MTClock::touch();

    ts, vs = { iv -> escapeTimeAndValue(arr[iv], depth) | iv < shp };
    return (ts, vs);
}

noinline
double[2:shp] normalizeValues(int[2:shp] ts, complex[2:shp] vs)
{
    MTClock::touch();

    return where(normSq(vs) <= 4d,
                 0d,
                 tod(ts + 1) - MathArray::log2(MathArray::log2(norm(vs))));
}

int main()
{
    // Count from the back because there may be cmdline arguments such as `-mt`
    XRES = String::toi(argv(argc() - 2));
    YRES = String::toi(argv(argc() - 1));

    arr = genComplexArray(XRES, YRES, toc(-2.2, 1.0), toc(0.8, -1.0));

    sec1, nsec1 = MTClock::gettime();

    ts, vs = escapeTimeAndValue(arr, DEPTH);
    nvs = normalizeValues(ts, vs);

    sec2, nsec2 = MTClock::gettime();
    printf("This took %fs\n", MTClock::timediff(sec1, nsec1, sec2, nsec2));
    printf("nvs[0,0] is %f\n", nvs[0,0]);
    printf("nvs[%d,%d] is %f\n", XRES/2, YRES/2, nvs[XRES/2,YRES/2]);

    return 0;
}

use Array: all;
use CommandLine: all;
use StdIO: all;

inline
float l2norm(float[d:shp] arr)
{
    return Math::sqrt(sum(arr * arr));
}

inline
float[m,n] stabilise(float[m,n] x)
{
    return { [i] -> x[i] - maxval(x[i]) | [i] < [m] };
}

inline
float[m,n] exp(float[m,n] x)
{
    return { iv -> Math::exp(x[iv]) | iv < [m,n] };
}

inline
float[m,n] scale(float[m,n] x)
{
    return { [i] -> x[i] / sum(x[i]) | [i] < [m] };
}

inline
float[m,n] matmulT(float[m,k] a, float[n,k] bT)
{
    return { [i,j] -> sum(a[i] * bT[j]) | [i,j] < [m,n] };
}

noinline
float[nd,d,d] FlashAttention(float[nd,d,d] Q, float[n,d] K, float[n,d] V)
    | (nd == n / d)
{
    MTClock::touch();

    Vt = transpose(V);
    return { [i] -> matmulT(scale(exp(stabilise(matmulT(Q[i], K)))), Vt)
           | [i] < [nd] };
}

int main()
{
    // Count from the back because there may be cmdline arguments such as `-mt`
    N = String::toi(argv(argc() - 2));
    D = String::toi(argv(argc() - 1));

    Q = { [i,j,k] -> 1f / (1f + tof(i)) | [i,j,k] < [N/D,D,D] };
    K = { [i,j] -> 1f | [i,j] < [N,D] };
    V = { [i,j] -> 1f | [i,j] < [N,D] };

    sec1, nsec1 = MTClock::gettime();

    O = FlashAttention(Q, K, V);

    sec2, nsec2 = MTClock::gettime();
    printf("This took %fs\n", MTClock::timediff(sec1, nsec1, sec2, nsec2));
    printf("l2norm is %f, should be %f\n", l2norm(O), Math::sqrt(tof(D*N)));

    return 0;
}

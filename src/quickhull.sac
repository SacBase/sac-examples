/*
SEQ 5000
CHECK 5000
MT 5000
*/

use Math: all;
use Array: all;
use CommandLine: all;
use StdIO: all;

#ifndef BLOCK
#define BLOCK 64
#endif

#define DBL_MAX 1.79769e+308

inline
double[2], double[2] swap(double[2] x, double[2] y)
{
    return (y, x);
}

inline
double orient(double[2] p, double[2] q, double[2] u)
{
    return (p[0] - u[0]) * (q[1] - u[1]) - (p[1] - u[1]) * (q[0] - u[0]);
}

inline
double, double[2] set_max(double o, double max, double[2] p, double[2] argmax)
{
    swap = tod(toi(o > max));
    max = (o > max) ? o : max;
    argmax = (1d - swap) * argmax + swap * p;
    return (max, argmax);
}

inline
double, int set_max(double o, double max, int index, int argmax)
{
    return ((o > max) ? o : max, (o > max) ? index : argmax);
}

inline
double[N,2], int, double[2] BlockHoare(double[N,2] P, int l, int r, double[2] p, double[2] q)
{
    r -= 1; // Point to the last element
    argmax = 0;

    max = -DBL_MAX;
    offsetsl = genarray([BLOCK], 0);
    offsetsr = genarray([BLOCK], 0);
    startl = 0;
    startr = 0;
    numl = 0;
    numr = 0;

    while (r - l > 2 * BLOCK) {
        if (numl == 0) {
            startl = 0;
            /* Sets offsets[0:numl] to the indices that have > 0 */
            for (i = 0; i < BLOCK; i++) {
                offsetsl[numl] = i;
                o = orient(p, q, P[l + i]);
                numl += toi(o > 0d);
                max, argmax = set_max(o, max, l + i, argmax);
            }
        }

        if (numr == 0) {
            startr = 0;
            /* Sets offsets[0:numr] to the indices that have <= 0 */
            for (i = 0; i < BLOCK; i++) {
                offsetsr[numr] = i;
                o = orient(p, q, P[r - i]);
                numr += toi(o <= 0d);
                max, argmax = set_max(o, max, r - i, argmax);
            }
        }

        num = (numl < numr) ? numl : numr;

        for (j = 0; j < num; j++) {
            Pr, Pl = swap(P[r - offsetsr[startr + j]],
                          P[l + offsetsl[startl + j]]);
            P[l + offsetsl[startl + j]] = Pl;
            P[r - offsetsr[startr + j]] = Pr;
        }

        for (j = 0; j < num; j++) {
            if (argmax == l + offsetsl[startl + j]) {
                argmax = r - offsetsr[startr + j];
            } else if (argmax == r - offsetsr[startr + j]) {
                argmax = l + offsetsl[startl + j];
            }
        }

        numl -= num;
        numr -= num;
        startl += num;
        startr += num;

        if (numl == 0) l += BLOCK;
        if (numr == 0) r -= BLOCK;
    }

    while (l <= r) {
        while (l <= r && orient(p, q, P[l]) <= 0d) {
          max, argmax = set_max(orient(p, q, P[l]), max, l, argmax);
          l++;
        }

        if (l <= r) {
            while (l <= r && orient(p, q, P[r]) > 0d) {
                max, argmax = set_max(orient(p, q, P[r]), max, r, argmax);
                r--;
            }
        }

        if (l < r) {
            if (argmax == l) {
                argmax = r;
            } else if (argmax == r) {
                argmax = l;
            }
            Pl, Pr = swap(P[l], P[r]);
            P[l] = Pl;
            P[r] = Pr;
        }
    }

    return (P, l, P[argmax]);
}

inline
double[2] min_x(double[2] a, double[2] b)
{
    return (a[0] < b[0] || (a[0] == b[0] && a[1] < b[1])) ? a : b;
}

inline
double[2] max_x(double[2] a, double[2] b)
{
    return (a[0] > b[0] || (a[0] == b[0] && a[1] > b[1])) ? a : b;
}

noinline
double[., .] QuickHull(double[N,2] P)
{
    MTClock::touch();

    hull = genarray(shape(P), 0d);

    /* Find the points with left-most and right-most x-coordinate. (In case of ties, with bottom and top y-coordinate)
     * These are guaranteed to be on the convex hull, and will be our first bisection. */
    left = 0;
    right = 0;
    for (i = 1; i < shape(P)[0]; i++) {
        if (P[i, 0] == P[left, 0]) {
            left = (P[i, 1] < P[left, 1]) ? i : left;
        } else if (P[i, 0] < P[left, 0]) {
            left = i;
        } else if (P[i, 0] == P[right, 0]) {
            right = (P[i, 1] > P[right, 1]) ? i : right;
        } else if (P[i, 0] > P[right, 0]) {
            right = i;
        }
    }

    p = P[left];
    q = P[right];

    hull[0] = p;

    P, c, r1 = BlockHoare(P, 0, N, p, q);
    P, lcount, hull = FindHull(P, c, N, p, q, r1, hull, 1);

    hull[lcount + 1] = q;

    P, c2, r2 = BlockHoare(P, 0, c, q, p);
    P, rcount, hull = FindHull(P, c2, c, q, p, r2, hull, lcount + 2);

    return take([lcount + rcount + 2], hull);
}

inline
double[N,2], int, double[N,2] FindHull(double[N,2] P, int lo, int hi, double[2] p, double[2] q,
                                       double[2] rk, double[N,2] hull, int hull_count)
{
    int count;

    if (lo != hi)  {
        P, c, t1 = BlockHoare(P, lo, hi, p, rk);
        P, lcount, hull = FindHull(P, c, hi, p, rk, t1, hull, hull_count);

        hull[lcount] = rk;

        P, c2, t2 = BlockHoare(P, lo, c, rk, q);
        P, rcount, hull = FindHull(P, c2, c, rk, q, t2, hull, hull_count + lcount + 1);

        count = 1 + lcount + rcount;
    } else {
        count = 0;
    }

    return (P, count, hull);
}

double[N,2] CreateCircle(int N)
{
    return { [i] -> [cos(tod(2 * i) * pi() / tod(N)), sin(tod(2 * i) * pi() / tod(N))]
           | [i] < [N] };
}

double[N,2] CreateQuad(int N)
{
    return { [i] -> [tod(i) / tod(N), (tod(i) / tod(N)) * (tod(i) / tod(N))]
           | [i] < [N] };
}

double[N,2] CreateHyperbola(int N, double A)
{
    return { [i] -> [tod(i + 1) / tod(N), tod(N) * A / tod(i + 1)]
           | [i] < [N] };
}

int main()
{
    // Count from the back because there may be cmdline arguments such as `-mt`
    N = String::toi(argv(argc() - 1));

    P = CreateCircle(N);

    sec1, nsec1 = MTClock::gettime();

    hull = QuickHull(P);

    sec2, nsec2 = MTClock::gettime();
    printf("This took %fs\n", MTClock::timediff(sec1, nsec1, sec2, nsec2));
    print(shape(hull));

    return 0;
}
